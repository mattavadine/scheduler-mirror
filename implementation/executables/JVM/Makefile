#
# This is a template Makefile to be put in the implementation/executables/JVM
# directory of a 309 project.  Goto the lines labeled "FILL IN HERE" to
# customize this template for your project.
#
# In order for this Makefile to work properly, your project directory must be
# set up per the 309 SOP, Volume 1.  In particular, you must have the following
# directories defined:
#
#   DIRECTORY                        CONTENTS
#   =====================================================================
#   implementation/source/java       root directory for the .java source files
#                                    of your project, organized into packages
#
#   implementation/executables/JVM   root directory for the .class executable
#                                    files generated by the Java compiler


# CSC 309 java lib directory
LIB309 =        fisher

#
# NOTES ABOUT EXECUTING COMPILED JAVA PROGRAMS.
#
# The compilation rule in the implementation-Makefile results in an executable
# program that consists of .class files stored in this directory --
# implementation/executables/JVM.  The program is invoked as follows from this
# directory:
#
#     java your-project.Main
#
# where "your-project" is the name of your top-level project package, and Main
# is the name of the class that contains the definition of the program's main
# method.  Executing in this way assumes that the CLASSPATH environment
# variable includes the path of the CSC 309 library directory, which on falcon
# is
#
#     /home/gfisher/classes/309/lib/JVM
#
# If CLASSPATH does not include this path, then the program can be invoked by
# specifying the CLASSPATH as a command-line argument as follows:
#
#     java -classpath /home/gfisher/classes/309/lib/JVM:. \
          your-project.Main
#
# Per standard Java invocation conventions, the preceding invocations assume
# that the current working directory is the executables/JVM directory in which
# the .class files reside.  If this is not the case, then the classpath must be
# extended with the directory in which the compiled package resides.
# Specifically, to run your-project.Main from some directory other than JVM,
# invoke it as follows:
#
#     java -classpath /home/gfisher/classes/309/lib/JVM:full-project-path/your-project/implementation/executables/JVM your-project.Main
#
# where "full-project-path" is the absolute path to the location of your
# project directory.
#
#
# The following make rules use the jar utility (the Java archiver) to build two
# other forms of executable programs -- one a transportable version and another
# that is a stand-alone executable version.  These rules should be run after
# the compilation has been performed in the implementation-Makefile in
# ../../source/java/Makefile.
#


# Run the Jar utility on all of the files to build a stand-alone executable
# .jar file that includes .class files, 309 library .class files, and a
# MANIFEST file that defines the Main-Class attribute as the Main class.
#
# This rule builds a jar file that can be invoked stand-alone, without
# unpacking it and without linking to the external 309 library.  It is invoked
# as follows:
#
#     java -jar your-program.jar
#
# This invocation can be performed in any working directory that contains a
# copy of your-program.jar, with no required settings of the CLASSPATH
# environment variable.  The stand-alone .jar file can also be invoked from any
# other working directory simply by specifying the full path to the location of
# the .jar file.
#
# FILL IN HERE: change "your-program" to a suitable name for the executable
# version of your program, e.g., the name of your top-level project package.
# Change "your-project" to the name of your top-level project package.  Also,
# create a file named MANIFEST containing the following single line:
#
#       Main-Class: your-project.Main
#
jar:
		jar cmf MANIFEST scheduler.jar scheduler \
		    -C $(LIB309) mvp -C sql .
		chmod a+x scheduler.jar

# Run the Jar utility on all of the files to build a transportable program
# archive file.
#
# FILL IN HERE: change "your-program" to a suitable name for the executable
# version of your program, e.g., the name of your top-level project package.
# Change "your-project" to the name of your top-level project package.
#
jar-simple:     $(FILES)
		jar cf scheduler.jar scheduler

# This .jar file is primarily intended for file transfer purposes, not for
# direct invocation.  For convenient execution from a jar file, see instead the
# exec rule below.  The .jar file can be invoked if desired as follows:
#
#    java -classpath \
	/home/gfisher/classes/309/lib/JVM:your-program.jar \
	your-project.Main
