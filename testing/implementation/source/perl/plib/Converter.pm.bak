package Converter;
use strict;
use warnings;
use 5.010;
use base qw(Exporter Class::Accessor);

#################################
# IMPORTS
#################################
use Data::Dumper;
use Course;
use Instructor;
use Location;
use File::Basename;
use Getopt::Long;

#################################
# EXPORTS
#################################
our @EXPORT = ();
our @EXPORT_OK = qw(convert getC_Data);

#################################
# FIELDS
#################################
our @data;
BEGIN
{
   @data = qw(cfile ifile lfile);
}
use fields (@data);
Converter->mk_accessors(@data);

sub accessor_name_for { "get\u$_[1]" }
sub mutator_name_for  { "set\u$_[1]" }

#################################
# CONSTANTS
#################################
my $prefix  = "CPE";
my $scheduler = "scheduler";

#################################
# GLOBALS
#################################
my %dfc;

#################################

sub new 
{
   my ($class, %args) = @_;
   
   my $self = fields::new($class);
   for (@data)
   {
      $self->{$_} = $args{$_} // die "Need '$_'";
   }

   $self;
}


sub convert
{
   my ($cFile, $iFile, $lFile, $className, $flags) = @_;
   
   die "Class name must be provided\n" unless $className;

   #
   # Allow user to supply a path to the file. Also, make the ".java" extension
   # optional, as I'll as it myself later
   #
   my ($baseName, $dirPath) = fileparse ($className, qw(.java));

   my ($cs, $is, $ls);
   
   if (defined $cFile)
   {
      eval
      {
         $cs = &getC_Data($cFile);
      };
      die "Error in file '$cFile'. Error $@\n" if $@;
   }
   if (defined $iFile)
   {
      eval
      {
         $is = &getI_Data($iFile);
      };
      die "Error in file '$iFile'. Error $@\n" if $@;
   }
   if (defined $lFile)
   {
      eval
      {
         $ls = &getL_Data($lFile);
      };
      die "Error in file '$lFile'. Error $@\n" if $@;
   }
   &makeClass ($dirPath, "\u$baseName", $cs, $is, $ls, $flags);
}

# getC_Data ==>
#
# Gathers all the data in the given file into Course object
#
sub getC_Data
{
   my $fn = shift;
   open (my $fh, "$fn") or die "$!\n";

   # Change input delimiter to ";"
   $/ = ";\n";

   my %classes;
   while (<$fh>)
   {
      chomp;
      if (/TODO/ or /^\s*$/)
      {
         next;
      }

      my $c;
      eval "\$c = Course->new($_);";
      die $@ if $@;
      $classes{$c->getId()} = $c;
         
      #
      # Add course's DFC's as they're needed
      #
      $dfc{$c->getDfc()} ++;
      if ($c->getLab())
      {
         $dfc{$c->getLab()->getDfc()} ++;
      }
   }

   # Chane input delimiter back
   $/ = "\n";

   \%classes;
}#<==

# parseCourseInfo ==>
sub parseCourseInfo
{
   my ($line) = @_;

   my ($id, $type, $sections, $dfc, $wtu, $scu) = 
      ($line =~ /(\d*)(\w*) - (\d*) - (\w*) - (\d*) - (\d*)/);
   
   # No "id" means there was nothing there to parse
   if ($id)
   {
      return 
      {
         id => $id, 
         type => $type, 
         sections => $sections, 
         dfc => $dfc, 
         wtu => $wtu, 
         scu => $scu
      };
   }
   else
   {
      return undef;
   }
}#<==

# getI_Data ==>
sub getI_Data
{
   my ($fn) = @_;
   open (my $fh, $fn) or die $!;

   # Change input delimiter for this one
   $/ = ";\n";

   my  %is;
   while (<$fh>)
   {
      chomp;
      next if /^\s*$/;

      my $i;
      eval "\$i = Instructor->new($_);";
      die $@ if $@;
      $is{$i->getId()} = $i;
   }

   # Change input delimiter back
   $/ = "\n";

   \%is;
}#<==

# getL_Data ==>
sub getL_Data
{
   my ($fn) = @_;
   open (my $fh, $fn) or die $!;

   my %ls;
   while (<$fh>)
   {
      next if (/^TODO/ or /^\s*$/);
      my ($type, $bldg, $room) = split(/:/);
      my $l = Location->new($type, $bldg, $room);
      $ls{$l->getName()} = $l;
   }

   \%ls;
}#<==

# makeClass ==>
#
# Note: I "select" the filehandle where the Java code will go. So calls to "say"
#       and "print" will, by default, go to the file
#
sub makeClass
{
   my ($fp, $fn, $courses, $instructors, $locations, $flags) = @_;

   open (my $fh, ">", "$fp$fn.java") or die "$!: $fp$fn.java";
   #
   # Default output is now the file!
   #
   select $fh;


   # Import packages
   &importPackages();

   # Begin class
   say "public class $fn\n{";

   # Global data
   &makeGlobalData(3, $courses, $locations);

   # Main
   &makeMain($courses, $instructors, $locations, $flags);

   # Make Instructor init'er methods
   &makeI_inits($instructors, $courses);

   # End class
   say "}";

   #
   # Default output is STDOUT
   #
   select STDOUT;
}#<==

# importPackages  ==>
sub importPackages
{
   say "import scheduler.*;";
   say "import scheduler.db.Time;";
   say "import scheduler.db.coursedb.*;";
   say "import scheduler.db.instructordb.*;";
   say "import scheduler.db.locationdb.*;";
   say "import scheduler.db.preferencesdb.*;";
   say "import scheduler.generate.Week;";
   say "import scheduler.menu.schedule.allInOne.*;";
   say "";

   say "import java.util.ArrayList;";
   say "import java.util.HashMap;";
   say "import java.util.LinkedHashMap;";
   say "import java.util.Vector;";
   say "import java.awt.*;";
   say "import java.awt.event.*;";
   say "import java.io.*;";

   say "";
}#<==

# makeMain ==>
sub makeMain
{
   my ($courses, $instructors, $locations, $flags) = @_;

   # Begin main
   say &indent(3, "public static void main (String[] argv)");
   say &indent(3, "{");

   say &indent(6, "Scheduler $scheduler = new Scheduler();\n");

   # Local LDB
   &makeLocalLDB(6, $locations);
   say "";

   # Local CDB
   &makeLocalCDB(6, $courses);
   say "";

   # Local IDB: Must happen after LDB and CDB have been set
   &makeLocalIDB(6, $instructors, $courses);
   say "";

   #
   # User can ask for the generated Java file to start up, generate a schedule,
   # and subsequently dump that to a file (specified as the value of "autoDump".
   #
   if ($flags->{autoDump})
   {
      #
      # Use the "Progress" class to let me see the progress of a shedule dump
      # while testing. Useful for debugging purposes
      #
      print &indent(6, "Progress p = new Progress(");
      print "new Vector<Course>($scheduler.getLocalCDB()), ";
      print "new Vector<Instructor>($scheduler.getLocalIDB()), ";
      print "new Vector<Location>($scheduler.getLocalLDB()), ";
      say "new Vector<SchedulePreference>());";
      say &indent(6, "p.execute();");

      #
      # We'll have to wait for the SwingWorker to finish before printing our
      # generated Schedule
      #
      print &indent(6, "while (p.getState() != ");
      say "javax.swing.SwingWorker.StateValue.DONE)";
      say &indent(6, "{");
      say &indent(9, "try { Thread.sleep(1000); }");
      say &indent(9, "catch (Exception e) { e.printStackTrace(); }");
      say &indent(6, "}");

      say &indent(6, "try");
      say &indent(6, "{");
      say &indent(9, "$scheduler.dumpAsPerlText(new PrintStream(".
         "new File(\"$flags->{autoDump}\")));");
      say &indent(6, "}");
      say &indent(6, "catch (FileNotFoundException e)");
      say &indent(6, "{");
      say &indent(9, "System.err.println (\"Couldn't open ".
         "'$flags->{autoDump}'\");");
      say &indent(6, "}");
      print &indent (6, "System.err.println(\"HERE\\n\" + $scheduler.getSchedule());");
      say &indent(6, "System.exit(0);");
   }
   else
   {
      say &indent(6, "$scheduler.schedulerUI.show(150, 100);");
   }

   # End main
   say &indent(3, "}\n");
}#<==

# makeGlobalData ==>
sub makeGlobalData
{
   my ($depth, $courses, $locations) = @_;

   say &indent($depth, "/* DFC's */");
   &makeDFCs($depth);
   say "";

   say &indent($depth, "/* COURSES */");
   &makeCourses($depth, $courses);
   say "";

   say &indent($depth, "/* LOCATIONS */");
   &makeLocations($depth, $locations);
   say "";
}#<==

# makeDFCs ==>
sub makeDFCs
{
   my ($depth) = @_;
   for (keys %dfc)
   {
      say &indent($depth, &makeDFC($_, 5));
   }
}#<==

# makeDFC ==>
sub makeDFC
{
   my ($dayStr, $weight) = @_;
   my @days = &parseAndMakeWeekList($dayStr);

   "public static final DaysForClasses $dayStr = ".
      "new DaysForClasses (\"$dayStr\", ".
                          "$weight, ".
                          "new int[] { ".join(", ", @days)." });";
}#<==

# parseAndMakeWeekList ==>
sub parseAndMakeWeekList
{
   my ($days) = @_;
   my @r;
   for (split (//, $days))
   {
      given ($_)
      {
         when (/m/i) { push (@r, "Week.MON")    }
         when (/t/i) { push (@r, "Week.TUE")    }
         when (/w/i) { push (@r, "Week.WED")    }
         when (/r/i) { push (@r, "Week.THU")    }
         when (/f/i) { push (@r, "Week.FRI")    }
         default     { die "Invalid day '$_'" }

      }
   }
   @r;
}#<== parseAndMakeWeekList

# makeCourses ==>
sub makeCourses
{
   my ($level, $courses) = @_;

   #
   # Courses are printed in ascending Id's
   #
   for my $c (sort { $a->getId() <=> $b->getId() } values %{$courses})
   {
      #
      # 'print' b/c I need better control of '\n'. It's tacked on on 
      # "makeCourse"
      #
      print &indent($level, &makeCourse($c->getLab()));  # Lab comes first,
                                                         # so Lec can use it.
                                                         # Will do nothing 
                                                         # if undef.
      print &indent($level, &makeCourse($c));
   }
}#<==

# makeCourse ==>
sub makeCourse
{
   my ($c) = @_;

   return "" unless $c; # For when you pass in the "lab" which doesn't exist

   "public static final Course ".$c->getName()." = ".$c->makeNewForJava()."\n";
}#<==

# makeLocations ==>
sub makeLocations
{
   my ($depth, $locations) = @_;

   say &indent($depth, "public static final Location l = ".
      "new Location (14, 200);");
   for (values %{$locations})
   {
      print &indent($depth, &makeLocation($_));
   }
}#<==

# makeLocation ==>
sub makeLocation
{
   my ($l) = @_;

   "public static final Location ".$l->getName()." = ".$l->getNewForJava()."\n";
}#<==

# makeLocalCDB ==>
sub makeLocalCDB
{
   my ($depth, $courses) = @_;

   # Put data in a Vector. Course objects are made in "makeGlobalData"
   say &indent($depth, "Vector<Course> cs = new Vector<Course>();");
   for ( map  { $_->getName() } 
         sort { $a->getId() <=> $b->getId() } values  %{$courses})
   {
      say &indent($depth, "cs.add($_);");
   }
   say &indent($depth, "$scheduler.cdb.setLocalData(cs);");
}#<==

# makeLocalLDB ==>
sub makeLocalLDB
{
   my ($depth, $locations) = @_;

   say &indent($depth, "Vector<Location> ls = new Vector<Location>();");
   for (map { $_->getName() } values %{$locations})
   {
      say &indent($depth, "ls.add($_);");
   }
   say &indent($depth, "$scheduler.ldb.setLocalData(ls);");
}#<==

# makeLocalIDB ==>
#
# MUST HAPPEN AFTER COURSES/LOCATIONS ARE ADDED TO THE SCHEDULER'S RESPECTIVE
# DATABASES! ELSE, BAD THINGS HAPPEN!
#
sub makeLocalIDB
{
   my ($depth, $is, $cs) = @_;

   say &indent($depth, "/* INSTRUCTORS */");
   &makeInstructors($depth, $is, $cs);

   say &indent($depth, "Vector<Instructor> is = new Vector<Instructor>();");
   for (map { $_->getId() } sort { $a->getId() cmp $b->getId() } values %{$is})
   {
      say &indent($depth, "is.add($_);");
   }
   say &indent($depth, "$scheduler.idb.setLocalData(is);");
}#<==

# makeInstructors ==>
sub makeInstructors
{
   my ($depth, $instructors, $cs) = @_;

   for my $i (sort { $a->getId() cmp $b->getId() } values %{$instructors})
   {
      &makeInstructor($depth, $i, $cs);
   }
}#<==

# makeInstructor ==>
sub makeInstructor
{
   my ($depth, $i, $cs) = @_;

   say &indent($depth, $_) for ($i->makeNewForJava($cs));
}#<==

sub makeI_inits
{
   my ($is, $cs) = @_;

   for my $i (values %{$is})
   {
      say &indent(3, $_) for $i->makeInitMethod($cs);
   }
}

# indent ==>
#
# $_[0] = Indentation level
# $_[1...] = Rest of message to print
#
sub indent
{
   unless ($_[1])
   {
      "";
   }
   else
   {
      " " x shift(@_) . "@_";
   }
}#<==


1;
